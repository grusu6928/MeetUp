<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MainFourCommands.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stars</a> &gt; <a href="index.source.html" class="el_package">edu.brown.cs.hshah9.stars</a> &gt; <span class="el_source">MainFourCommands.java</span></div><h1>MainFourCommands.java</h1><pre class="source lang-java linenums">package edu.brown.cs.hshah9.stars;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;

/**
 * This is a superclass for NaiveNeighborsCommand, NaiveRadiusCommand, NeighborsCommand,
 * and RadiusCommand. It holds functionality shared by all four subclasses
 * (e.g. error checking, calculating the distance from a given star to a
 * point of interest, etc.
 */
public class MainFourCommands {

  // valid commands only have 2 or 4 arguments
<span class="fc" id="L18">  private ArrayList&lt;Integer&gt; numPossibleArgs = new ArrayList&lt;Integer&gt;(Arrays.asList(2, 4));</span>

  private String errorMessage;

  /**
   * Instantiates the superclass.
   */
<span class="fc" id="L25">  public MainFourCommands() {</span>
<span class="fc" id="L26">  }</span>

  // for GUI

  /**
   * Gets the error that occurred (if an error occurred).
   * @return the error
   */
  public String getErrorMessage() {
<span class="fc" id="L35">    return this.errorMessage;</span>
  }


  // USED: ALL 4 CLASSES ////

  // CALLS: nameVersionErrorCheck, corVersionErrorCheck
  // FUNCTIONALITY: CHECK FOR ERRORS IN inputted commands
  // USED IN ALL 4
  // command type -&gt; 0 is neighbors, 1 is radius

  /**
   * Error checks the caller's input and if data has been loaded before the caller calls a command.
   * Makes calls to helper functions: numNeighOrRadiusErrorCheck, nameVersionErrorCheck,
   * corVersionErrorCheck.
   * @param input the caller's input
   * @param commandType 0 specifies naive/optimized neighbors call;
   *                    1 specifies naive/optimized radius call
   * @return true if there's an error; false o.w.
   */
  public boolean errorCheck(String[] input, int commandType) {

<span class="fc bfc" id="L57" title="All 2 branches covered.">    if (input == null) {</span>
<span class="fc" id="L58">      this.errorMessage = &quot;ERROR: input is null&quot;;</span>
<span class="fc" id="L59">      System.out.println(this.errorMessage);</span>
<span class="fc" id="L60">      return true;</span>
    }

<span class="fc" id="L63">    ArrayList&lt;Star&gt; data = SharedData.getInstance().getStarsData();</span>

<span class="pc bpc" id="L65" title="1 of 2 branches missed.">    if (data == null) {</span>
<span class="nc" id="L66">      this.errorMessage = &quot;ERROR: no csv file loaded&quot;;</span>
<span class="nc" id="L67">      System.out.println(this.errorMessage);</span>
<span class="nc" id="L68">      return true;</span>
    }

<span class="fc" id="L71">    Integer numArgs = input.length - 1;</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">    boolean nameVersion = numArgs == 2;</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">    boolean corVersion = numArgs == 4;</span>

<span class="pc bpc" id="L75" title="1 of 2 branches missed.">    if (!numPossibleArgs.contains(numArgs)) {</span>
<span class="nc" id="L76">      this.errorMessage = &quot;ERROR: incorrect number of arguments&quot;;</span>
<span class="nc" id="L77">      System.out.println(this.errorMessage);</span>
<span class="nc" id="L78">      return true;</span>
    }

    // HELPER: type checks and non-negative checks radius and numNeighbors
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">    if (this.numNeighOrRadiusErrorCheck(commandType, input[1])) {</span>
<span class="nc" id="L83">      return true;</span>
    }

    // HERLPER: more specific checks for name or coordinate version
<span class="fc bfc" id="L87" title="All 2 branches covered.">    if (nameVersion) {</span>
<span class="fc" id="L88">      return nameVersionErrorCheck(input);</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">    } else if (corVersion) {</span>
<span class="fc" id="L90">      return corVersionErrorCheck(input);</span>
    }

<span class="nc" id="L93">    return false;</span>
  }

  /**
   * Type checks and non-negative checks the number of neighbors / the radius
   * specifed by the caller.
   * @param commandType 0: neighbors; 1: radius
   * @param value the 1st argument of the user's input
   * @return true if error; false o.w.
   */
  private boolean numNeighOrRadiusErrorCheck(int commandType, String value) {
<span class="fc bfc" id="L104" title="All 2 branches covered.">    boolean neighborsCommand = commandType == 0;</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">    boolean radiusCommand = commandType == 1;</span>

<span class="fc bfc" id="L107" title="All 2 branches covered.">    if (neighborsCommand) {</span>
      try {
<span class="fc" id="L109">        int numNeighbors = Integer.parseInt(value);</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        if (numNeighbors &lt; 0) {</span>
<span class="nc" id="L111">          this.errorMessage = &quot;ERROR: number of neighbors to find must be non-negative&quot;;</span>
<span class="nc" id="L112">          System.out.println(this.errorMessage);</span>
<span class="nc" id="L113">          return true;</span>
        }
<span class="nc" id="L115">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L116">        this.errorMessage = &quot;ERROR: Improperly formatted number of neighbors to find inputted&quot;;</span>
<span class="nc" id="L117">        System.out.println(this.errorMessage);</span>
<span class="nc" id="L118">        return true;</span>
<span class="fc" id="L119">      }</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">    } else if (radiusCommand) {</span>
      try {
<span class="fc" id="L122">        double radius = Double.parseDouble(value);</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        if (Double.compare(radius, 0) &lt; 0) {</span>
<span class="nc" id="L124">          this.errorMessage = &quot;ERROR: radius must be non-negative&quot;;</span>
<span class="nc" id="L125">          System.out.println(this.errorMessage);</span>
<span class="nc" id="L126">          return true;</span>
        }
<span class="nc" id="L128">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L129">        this.errorMessage = &quot;ERROR: Improperly formatted radius inputted&quot;;</span>
<span class="nc" id="L130">        System.out.println(this.errorMessage);</span>
<span class="nc" id="L131">        return true;</span>
<span class="fc" id="L132">      }</span>
    }

<span class="fc" id="L135">    return false;</span>
  }


  private boolean nameVersionErrorCheck(String[] input) {

<span class="fc" id="L141">    String starName = input[2];</span>
<span class="fc" id="L142">    char firstChar = starName.charAt(0);</span>
<span class="fc" id="L143">    char lastChar = starName.charAt(starName.length() - 1);</span>

<span class="pc bpc" id="L145" title="2 of 4 branches missed.">    if (!(firstChar == '&quot;') || !(lastChar == '&quot;')) {</span>
<span class="nc" id="L146">      this.errorMessage = &quot;ERROR: Star name must be enclosed in quotation marks&quot;;</span>
<span class="nc" id="L147">      System.out.println(this.errorMessage);</span>
<span class="nc" id="L148">      return true;</span>
    }

<span class="fc" id="L151">    starName = starName.substring(1, starName.length() - 1);</span>

<span class="pc bpc" id="L153" title="2 of 4 branches missed.">    if (!starExists(starName) || starName.equals(&quot;&quot;)) {</span>
<span class="nc" id="L154">      this.errorMessage = &quot;ERROR: No such star exists in the loaded file&quot;;</span>
<span class="nc" id="L155">      System.out.println(this.errorMessage);</span>
<span class="nc" id="L156">      return true;</span>
    }

<span class="fc" id="L159">    return false;</span>
  }


  private boolean corVersionErrorCheck(String[] input) {

<span class="fc" id="L165">    String xCor = input[2];</span>
<span class="fc" id="L166">    String yCor = input[3];</span>
<span class="fc" id="L167">    String zCor = input[4];</span>

    try {
<span class="fc" id="L170">      Double.parseDouble(xCor);</span>
<span class="fc" id="L171">      Double.parseDouble(yCor);</span>
<span class="fc" id="L172">      Double.parseDouble(zCor);</span>
<span class="nc" id="L173">    } catch (NumberFormatException e) {</span>
<span class="nc" id="L174">      this.errorMessage = &quot;ERROR: Improperly formatted coordinate(s) inputted&quot;;</span>
<span class="nc" id="L175">      System.out.println(this.errorMessage);</span>
<span class="nc" id="L176">      return true;</span>
<span class="fc" id="L177">    }</span>

<span class="fc" id="L179">    return false;</span>
  }


  /**
   * Checks if starName is in the SharedData HashMap (efficient check).
   * @param starName starName to look for
   * @return true if exists; false otherwise
   */
  public boolean starExists(String starName) {
<span class="fc" id="L189">    HashMap&lt;String, Star&gt; nameToStar = SharedData.getInstance().getNameToStar();</span>
<span class="fc" id="L190">    return nameToStar.keySet().contains(starName);</span>
  }

  /**
   * Returns the coordinates of a star after quick HashMap lookup.
   * @param starName starName to look for
   * @return double array of star's coordinates
   */
  public double[] getCoordinates(String starName) {
<span class="fc" id="L199">    HashMap&lt;String, Star&gt; nameToStar = SharedData.getInstance().getNameToStar();</span>
<span class="fc" id="L200">    return nameToStar.get(starName).getCoors();</span>
  }

  /**
   * Determines the coordinates of the caller-specified point of interest. Handles both when
   * a star name is specified and, more trivially, when the coordinates are provided.
   * @param input user input
   * @param nameVersion true: nameVersion; false: corVersion
   * @return array of doubles holding point of interest
   */
  public double[] determinePOI(String[] input, boolean nameVersion) {
    double[] coors;
<span class="fc bfc" id="L212" title="All 2 branches covered.">    if (nameVersion) {</span>
      // remove quotes around name
<span class="fc" id="L214">      String starName = input[2].substring(1, input[2].length() - 1);</span>
<span class="fc" id="L215">      coors = this.getCoordinates(starName);</span>
<span class="fc" id="L216">    } else {</span>
<span class="fc" id="L217">      coors = new double[3];</span>
<span class="fc" id="L218">      coors[0] = Double.parseDouble(input[2]);</span>
<span class="fc" id="L219">      coors[1] = Double.parseDouble(input[3]);</span>
<span class="fc" id="L220">      coors[2] = Double.parseDouble(input[4]);</span>
    }
<span class="fc" id="L222">    return coors;</span>
  }



  /**
   * Calculates Euclidean distance between point of interest and a star.
   * @param poi coordinates of point of interest
   * @param star star from which to calc distance to poi
   * @return Euclidean distance from star to poi
   */
  public double calcDistance(double[] poi, Star star) {
<span class="fc" id="L234">    Double xPOI = poi[0];</span>
<span class="fc" id="L235">    Double yPOI = poi[1];</span>
<span class="fc" id="L236">    Double zPOI = poi[2];</span>
<span class="fc" id="L237">    Double starX = star.getCoors()[0];</span>
<span class="fc" id="L238">    Double starY = star.getCoors()[1];</span>
<span class="fc" id="L239">    Double starZ = star.getCoors()[2];</span>

<span class="fc" id="L241">    return Math.sqrt(Math.pow(xPOI - starX, 2) + Math.pow(yPOI - starY, 2)</span>
<span class="fc" id="L242">            + Math.pow(zPOI - starZ, 2));</span>
  }




  /**
   * Sorts a list by the comparator specified by the caller. The comparator can only compare
   * objects that implement the HasCoordinates interface.
   * @param list list to sort
   * @param comparator comparator by which to sort
   * @return sorted list of stars
   */
  public ArrayList&lt;Star&gt; sortList(ArrayList&lt;Star&gt; list, Comparator&lt;HasCoordinates&gt; comparator) {

<span class="fc" id="L257">    Collections.sort(list, comparator); // sort stars from closest to furthest</span>
<span class="fc" id="L258">    return list;</span>
  }


  /**
   * Prints out the IDs of the stars in a list.
   * @param list list of stars from which to print IDs
   */
  public void printIds(ArrayList&lt;Star&gt; list) {
<span class="fc bfc" id="L267" title="All 2 branches covered.">    for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="fc" id="L268">      System.out.println(list.get(i).getId());</span>
    }
<span class="fc" id="L270">  }</span>



}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>